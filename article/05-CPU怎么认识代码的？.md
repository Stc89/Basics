# 05-CPU怎么认识代码的？

# # 语言这个东西？

首先说明下，我们正常使用的python、C++、C语言等等，我们自己能读得懂的语言，包括汇编语言，CPU都是不认识的，CPU 只认识一种语言，那就是 `机器语言`，也就是我们很多人，或者很多老师，或者很多老鸟，很多大佬都提到的 **机器码**。

<img src="https://raw.githubusercontent.com/weiqifa0/pic/master/image-20200929162855439.png" alt="高级语言和机器语言" style="zoom:120%;" />

# #机器码是什么？

机器码是CPU可以认识的，可以按照这个机器码去执行相对应指令的代码，我们可以认识它就是一些 **十六进制** 字符。

比如下面这些，就是机器码

```
:200000007592007591007590FFC294C295C29612001ED294D295D29612001E0200097DC8E5
:0B0020007EC87FF8DFFEDEFADDF6226E
:00000001FF
```

# # CPU上电执行程序过程

RAM 和 ROM 是永远躲不开的话题，我们编译成的机器码最后会烧录到一个ROM的位置，这个位置保存的东西掉电可保存，这个是基本操作。

然后开机的第一件事，就是把ROM**里面的程式**，程式是很多台湾的工程师这样说明的，我们叫程序，不管叫什么，都是一堆二进制代码，把这些代码拷贝到RAM里面，然后CPU就从RAM的指定位置去开始执行程序。

![很经典](https://raw.githubusercontent.com/weiqifa0/pic/master/image-20200929163357377.png)

# #什么是汇编代码？

汇编代码和机器码是有对应关系的，所以我们很多时候分析一个C语言代码的流程，**特别是那种未定义行为的时候**，我们都反编译成汇编来看，汇编代码就代表了CPU的执行顺序，CPU就是按照汇编代码来执行对应的指令的。

如下是一段汇编代码

```
;流水灯程序

P1M0 DATA 092H
P1M1 DATA 091H
ORG 00H
MOV P1M0,#00000000B
MOV P1M1,#00000000B
MOV P1,#11111111B

START:
    CLR P1.4        ; 置0，
    CLR P1.5        ; 置0，
    CLR P1.6        ; 置0，
    LCALL DELAY     ; 延时0.2s
    SETB P1.4       ; 置1，点亮LED
    SETB P1.5       ; 置1，点亮LED
    SETB P1.6       ; 置1，点亮LED
    LCALL DELAY     ; 延时0.2s
    LJMP START      ; 进行重新循环
DELAY:
    MOV R5,#200      ; 执行MOV指令为1个机器周期
D1:
    MOV R6, #200     ; 执行的时间为：1*20 个机器周期
D2:
    MOV R7, #248    ; 该条指令执行了: 1*20*20
    DJNZ R7,$       ; 该条指令执行了: 2*20*20*248
    DJNZ R6, D2     ; 该条指令执行了: 2*20*20 个机器周期
    DJNZ R5, D1     ; 该条指令执行了: 2*20
    RET             ; 该条指令执行了: 2

END
```



# #机器代码和汇编代码的对应关系

每个CPU都有指令集，这个对应关系也就是指令集的对应关系，例如51单片机是这样的。

![指令集](https://raw.githubusercontent.com/weiqifa0/pic/master/image-20200929164019956.png)

如果我们使用wave来编写汇编代码的话，可以看到汇编代码和机器码的对应关系

![汇编对应机器码](https://raw.githubusercontent.com/weiqifa0/pic/master/image-20200929164257015.png)

我们随便解析一个指令

```
 CLR P1.4        ; 置0，
 CLR P1.5        ; 置0，
 CLR P1.6        ; 置0，
```

这三条指令是把 对应的GPIO口拉低的，这三条指令对应的机器码是

```
0009H C294 CLR P1.4
000BH C295 CLR P1.5
000DH C296 CLR P1.6
```

我们看看指令集里面的C2是干嘛的

```
CLR bit 直接位清  C2
```

那后面对应的 `94`是什么意思呢？
看看这个图片就明白了，P1口的地址是90H，P1.4就是偏移 4位，那就是94H了

![image-20200929173924948](https://raw.githubusercontent.com/weiqifa0/pic/master/image-20200929173924948.png)



# #后续

这篇文章就先讲这么多，还有hex和bin文件的关系，还是有很多东西可以深挖的，后面在讲讲。