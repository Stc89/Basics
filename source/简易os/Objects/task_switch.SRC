; .\Objects\task_switch.SRC generated from: task_switch.c
; COMPILER INVOKED BY:
;        C:\Keil\C51\BIN\C51.EXE task_switch.c BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\task_switch.lst) SRC(.\Objects\task_switch.SRC)

$NOMOD51

NAME	TASK_SWITCH

P0M1	DATA	093H
P1M0	DATA	092H
P2M0	DATA	096H
P1M1	DATA	091H
P0	DATA	080H
P3M0	DATA	0B2H
P2M1	DATA	095H
P1	DATA	090H
P4M0	DATA	0B4H
P3M1	DATA	0B1H
P2	DATA	0A0H
P5M0	DATA	0CAH
P4M1	DATA	0B3H
P3	DATA	0B0H
WKTCH	DATA	0ABH
AC	BIT	0D0H.6
P6M0	DATA	0CCH
P5M1	DATA	0C9H
P4	DATA	0C0H
P7M0	DATA	0E2H
P6M1	DATA	0CBH
P5	DATA	0C8H
P6	DATA	0E8H
P7M1	DATA	0E1H
EA	BIT	0A8H.7
P7	DATA	0F8H
WKTCL	DATA	0AAH
SPCTL	DATA	0CEH
P_SW1	DATA	0A2H
P_SW2	DATA	0BAH
DPH1	DATA	0E5H
EADC	BIT	0A8H.5
IE	DATA	0A8H
IAP_CMD	DATA	0C5H
DPL1	DATA	0E4H
ADC_RES	DATA	0BDH
IP2H	DATA	0B6H
IP3H	DATA	0EEH
TA	DATA	0AEH
INTCLKO	DATA	08FH
ES	BIT	0A8H.4
PADC	BIT	0B8H.5
IP	DATA	0B8H
ADCCFG	DATA	0DEH
RI	BIT	098H.0
CY	BIT	0D0H.7
TI	BIT	098H.1
IAP_ADDRH	DATA	0C3H
PS	BIT	0B8H.4
SP	DATA	081H
IAP_ADDRL	DATA	0C4H
OV	BIT	0D0H.2
PPCA	BIT	0B8H.7
LIRTRIM	DATA	09EH
CMPCR1	DATA	0E6H
CMPCR2	DATA	0E7H
ELVD	BIT	0A8H.6
P00	BIT	080H.0
ADC_CONTR	DATA	0BCH
SBUF	DATA	099H
P10	BIT	090H.0
PCON	DATA	087H
P01	BIT	080H.1
P20	BIT	0A0H.0
P11	BIT	090H.1
P02	BIT	080H.2
IAP_TPS	DATA	0F5H
P30	BIT	0B0H.0
P21	BIT	0A0H.1
P12	BIT	090H.2
P03	BIT	080H.3
P40	BIT	0C0H.0
P31	BIT	0B0H.1
P22	BIT	0A0H.2
SCON	DATA	098H
P13	BIT	090H.3
P04	BIT	080H.4
P50	BIT	0C8H.0
P41	BIT	0C0H.1
P32	BIT	0B0H.2
P23	BIT	0A0H.3
P14	BIT	090H.4
TMOD	DATA	089H
TCON	DATA	088H
P05	BIT	080H.5
P51	BIT	0C8H.1
P42	BIT	0C0H.2
P33	BIT	0B0H.3
P24	BIT	0A0H.4
P15	BIT	090H.5
P06	BIT	080H.6
P52	BIT	0C8H.2
P43	BIT	0C0H.3
PLVD	BIT	0B8H.6
P34	BIT	0B0H.4
P25	BIT	0A0H.5
P16	BIT	090H.6
P07	BIT	080H.7
P53	BIT	0C8H.3
P44	BIT	0C0H.4
P35	BIT	0B0H.5
P26	BIT	0A0H.6
P17	BIT	090H.7
P54	BIT	0C8H.4
P45	BIT	0C0H.5
P36	BIT	0B0H.6
P27	BIT	0A0H.7
P46	BIT	0C0H.6
P37	BIT	0B0H.7
P47	BIT	0C0H.7
IE0	BIT	088H.1
IE1	BIT	088H.3
IE2	DATA	0AFH
B	DATA	0F0H
AUXR	DATA	08EH
USBADR	DATA	0FCH
IAP_CONTR	DATA	0C7H
USBDAT	DATA	0ECH
USBCLK	DATA	0DCH
ACC	DATA	0E0H
ET0	BIT	0A8H.1
ET1	BIT	0A8H.3
TF0	BIT	088H.5
RSTCFG	DATA	0FFH
IP2	DATA	0B5H
TF1	BIT	088H.7
USBCON	DATA	0F4H
IP3	DATA	0DFH
RB8	BIT	098H.2
TH0	DATA	08CH
EX0	BIT	0A8H.0
TH1	DATA	08DH
IT0	BIT	088H.0
T2H	DATA	0D6H
EX1	BIT	0A8H.2
TB8	BIT	098H.3
IT1	BIT	088H.2
T3H	DATA	0D4H
P	BIT	0D0H.0
T4H	DATA	0D2H
SM0	BIT	098H.7
TL0	DATA	08AH
SM1	BIT	098H.6
TL1	DATA	08BH
T2L	DATA	0D7H
SM2	BIT	098H.5
T3L	DATA	0D5H
T4L	DATA	0D3H
PT0	BIT	0B8H.1
RS0	BIT	0D0H.3
PT1	BIT	0B8H.3
RS1	BIT	0D0H.4
IAP_DATA	DATA	0C2H
TR0	BIT	088H.4
TR1	BIT	088H.6
WDT_CONTR	DATA	0C1H
PX0	BIT	0B8H.0
PX1	BIT	0B8H.2
IRTRIM	DATA	09FH
DPH	DATA	083H
T4T3M	DATA	0D1H
ADC_RESL	DATA	0BEH
DPL	DATA	082H
SPSTAT	DATA	0CDH
IPH	DATA	0B7H
S2BUF	DATA	09BH
S3BUF	DATA	0ADH
REN	BIT	098H.4
S4BUF	DATA	085H
S2CON	DATA	09AH
DPS	DATA	0E3H
S3CON	DATA	0ACH
S4CON	DATA	084H
AUXINTIF	DATA	0EFH
SADEN	DATA	0B9H
SADDR	DATA	0A9H
IAP_TRIG	DATA	0C6H
F0	BIT	0D0H.5
IRCBAND	DATA	09DH
PSW	DATA	0D0H
SPDAT	DATA	0CFH
P0M0	DATA	094H
?PR?os_cpu_sr_save?TASK_SWITCH           SEGMENT CODE 
?PR?_os_cpu_sr_restore?TASK_SWITCH       SEGMENT CODE 
?PR?_os_tesk_stack_init?TASK_SWITCH      SEGMENT CODE 
?DT?_os_tesk_stack_init?TASK_SWITCH      SEGMENT DATA OVERLAYABLE 
?PR?_os_delay?TASK_SWITCH                SEGMENT CODE 
?DT?_os_delay?TASK_SWITCH                SEGMENT DATA OVERLAYABLE 
?PR?os_time_tick?TASK_SWITCH             SEGMENT CODE 
?PR?timer0_isr?TASK_SWITCH               SEGMENT CODE 
?DT?timer0_isr?TASK_SWITCH               SEGMENT DATA OVERLAYABLE 
	EXTRN	DATA (os_task_running_id)
	EXTRN	CODE (os_int_enter)
	EXTRN	DATA (os_map_tab)
	EXTRN	DATA (os_int_count)
	EXTRN	CODE (os_int_exit)
	EXTRN	DATA (os_task_rdy_tab)
	EXTRN	BIT (os_running)
	EXTRN	IDATA (os_tcb)
	PUBLIC	timer0_isr
	PUBLIC	os_time_tick
	PUBLIC	_os_delay
	PUBLIC	_os_tesk_stack_init
	PUBLIC	_os_cpu_sr_restore
	PUBLIC	os_cpu_sr_save

	RSEG  ?DT?timer0_isr?TASK_SWITCH
?timer0_isr?BYTE:
     cpu_sr?547:   DS   1

	RSEG  ?DT?_os_tesk_stack_init?TASK_SWITCH
?_os_tesk_stack_init?BYTE:
       r_sp?242:   DS   1

	RSEG  ?DT?_os_delay?TASK_SWITCH
?_os_delay?BYTE:
      tisks?343:   DS   1
; #include "task_switch.h"
; #include "reg51.h"
; #include "core.h"
; 
; 
; /* 进入临界段 */
; char os_cpu_sr_save(void)

	RSEG  ?PR?os_cpu_sr_save?TASK_SWITCH
os_cpu_sr_save:
	USING	0
			; SOURCE LINE # 7
; {
			; SOURCE LINE # 8
; 	__asm mov r7,IE		//得到 「IE」中断控制寄存器值
	 mov r7,IE		 
; 	__asm mov IE,#0
	 mov IE,#0
; 	__asm ret			//返回值是在r7中
	 ret			 
; 	return 0;			//返回这条指令实际不会被执行到,但因为这个函数确实要返回值,所以写一下(不然会有警告)
			; SOURCE LINE # 12
	MOV  	R7,#00H
; }
			; SOURCE LINE # 13
?C0001:
	RET  	
; END OF os_cpu_sr_save

; 
; 
; /* 退出临界段 */
; void os_cpu_sr_restore(char cpu_sr)

	RSEG  ?PR?_os_cpu_sr_restore?TASK_SWITCH
_os_cpu_sr_restore:
	USING	0
			; SOURCE LINE # 17
;---- Variable 'cpu_sr?140' assigned to Register 'R7' ----
; {
			; SOURCE LINE # 18
; 	cpu_sr = cpu_sr;	//第一个参数(char类型)是存在r7里面的,
			; SOURCE LINE # 19
; 	__asm mov IE,r7		//恢复中断控制寄存器值
	 mov IE,r7		 
; 	__asm ret			//也可以没有(函数会有ret)
	 ret			 
; }
			; SOURCE LINE # 22
	RET  	
; END OF _os_cpu_sr_restore

; 
; 
; 
; /* 任务堆栈初始化 */
; unsigned char os_tesk_stack_init(unsigned char stack_point)

	RSEG  ?PR?_os_tesk_stack_init?TASK_SWITCH
_os_tesk_stack_init:
	USING	0
			; SOURCE LINE # 27
;---- Variable 'stack_point?241' assigned to Register 'R7' ----
; {
			; SOURCE LINE # 28
; 	unsigned char r_sp = SP;
			; SOURCE LINE # 29
	MOV  	r_sp?242,SP
; 	SP = stack_point;	//寄存器入栈(在此之前不能有任何运算操作,不然会改变寄存器值)
			; SOURCE LINE # 30
	MOV  	SP,R7
; 	__asm PUSH ACC		//累加器	
	 PUSH ACC		 
; 	__asm PUSH B		//用于乘除的寄存器
	 PUSH B		 
; 	__asm PUSH DPH		//数据指针，用途大
	 PUSH DPH		 
; 	__asm PUSH DPL		//数据指针，用途大
	 PUSH DPL		 
; 	__asm PUSH PSW		//标志位寄存器
	 PUSH PSW		 
; 	__asm PUSH 0
	 PUSH 0
; 	__asm PUSH 1
	 PUSH 1
; 	__asm PUSH 2
	 PUSH 2
; 	__asm PUSH 3
	 PUSH 3
; 	__asm PUSH 4
	 PUSH 4
; 	__asm PUSH 5
	 PUSH 5
; 	__asm PUSH 6
	 PUSH 6
; 	__asm PUSH 7
	 PUSH 7
; 
; 	stack_point = SP;
			; SOURCE LINE # 45
	MOV  	R7,SP
; 	SP = r_sp;
			; SOURCE LINE # 46
	MOV  	SP,r_sp?242
; 
; 	return stack_point;
			; SOURCE LINE # 48
; }
			; SOURCE LINE # 49
?C0003:
	RET  	
; END OF _os_tesk_stack_init

; 
; 
; /*因为没有对PC直接操作的指令,但中断过程和过程调用可以使PC入栈,
; 中断返回,过程返回可以,使PC出栈,可以间接的利用此方法对PC操作*/
; 
; /* 系统延时 */
; void os_delay(unsigned char tisks)

	RSEG  ?PR?_os_delay?TASK_SWITCH
_os_delay:
	USING	0
			; SOURCE LINE # 56
	MOV  	tisks?343,R7
; {
			; SOURCE LINE # 57
; 	unsigned char i;
; 
; 	if(tisks > 0)
			; SOURCE LINE # 60
	MOV  	A,tisks?343
	SETB 	C
	SUBB 	A,#00H
	JNC  	$ + 5H
	LJMP 	?C0010
; 	{
			; SOURCE LINE # 61
; 		EA = 0;						//直接操作,而不用临界段的方法主要是为了任务切换更快
			; SOURCE LINE # 62
	CLR  	EA
; 		/*压栈*/
; 		__asm PUSH ACC				//寄存器入栈(在此之前不能有任何运算操作,不然会改变寄存器值)
	 PUSH ACC				 
; 		__asm PUSH B
	 PUSH B
; 		__asm PUSH DPH
	 PUSH DPH
; 		__asm PUSH DPL
	 PUSH DPL
; 		__asm PUSH PSW
	 PUSH PSW
; 		__asm PUSH 0
	 PUSH 0
; 		__asm PUSH 1
	 PUSH 1
; 		__asm PUSH 2
	 PUSH 2
; 		__asm PUSH 3
	 PUSH 3
; 		__asm PUSH 4
	 PUSH 4
; 		__asm PUSH 5
	 PUSH 5
; 		__asm PUSH 6
	 PUSH 6
; 		__asm PUSH 7
	 PUSH 7
; 		os_tcb[os_task_running_id].os_task_stcak_top = SP;
			; SOURCE LINE # 77
	MOV  	R7,os_task_running_id
	MOV  	A,R7
	ADD  	A,ACC
	ADD  	A,ACC
	ADD  	A,#LOW (os_tcb+01H)
	MOV  	R0,A
	MOV  	@R0,SP
; 		os_tcb[os_task_running_id].os_tsak_wait_tick = tisks;	//延时时间
			; SOURCE LINE # 78
	MOV  	R7,os_task_running_id
	MOV  	A,R7
	ADD  	A,ACC
	ADD  	A,ACC
	ADD  	A,#LOW (os_tcb)
	MOV  	R0,A
	MOV  	@R0,tisks?343
; 		os_tcb[os_task_running_id].suspend = 1;					//因为有延时,所以先挂起本任务
			; SOURCE LINE # 79
	MOV  	R7,os_task_running_id
	MOV  	A,R7
	ADD  	A,ACC
	ADD  	A,ACC
	ADD  	A,#LOW (os_tcb+03H)
	MOV  	R0,A
	MOV  	@R0,#01H
; 		for(i=0; i<MAX_TASK; i++)								//找到已经就绪,未被挂起,且优先级最高的任务
			; SOURCE LINE # 80
;---- Variable 'i?344' assigned to Register 'R7' ----
	CLR  	A
	MOV  	R7,A
?C0005:
; 		{
			; SOURCE LINE # 81
; 			if(os_task_rdy_tab & os_map_tab[i])
			; SOURCE LINE # 82
	MOV  	A,#LOW (os_map_tab)
	ADD  	A,R7
	MOV  	R0,A
	MOV  	A,@R0
	ANL  	A,os_task_rdy_tab
	JZ   	?C0007
; 			{
			; SOURCE LINE # 83
; 				if(0 == os_tcb[i].suspend)
			; SOURCE LINE # 84
	MOV  	A,R7
	ADD  	A,ACC
	ADD  	A,ACC
	ADD  	A,#LOW (os_tcb+03H)
	MOV  	R0,A
	MOV  	A,@R0
	JZ   	?C0006
; 				{
			; SOURCE LINE # 85
; 					break;
			; SOURCE LINE # 86
; 				}
			; SOURCE LINE # 87
?C0009:
; 			}
			; SOURCE LINE # 88
; 		}
			; SOURCE LINE # 89
?C0007:
	INC  	R7
	CJNE 	R7,#03H,?C0005
?C0006:
; 		os_task_running_id = i;								//可执行的最高优先级任务
			; SOURCE LINE # 90
	MOV  	os_task_running_id,R7
; 
; 		SP = os_tcb[os_task_running_id].os_task_stcak_top;	//最高优先级任务的栈顶
			; SOURCE LINE # 92
	MOV  	R7,os_task_running_id
	MOV  	A,R7
	ADD  	A,ACC
	ADD  	A,ACC
	ADD  	A,#LOW (os_tcb+01H)
	MOV  	R0,A
	MOV  	A,@R0
	MOV  	SP,A
; 		/*出栈*/
; 		__asm POP 7
	 POP 7
; 		__asm POP 6
	 POP 6
; 		__asm POP 5
	 POP 5
; 		__asm POP 4
	 POP 4
; 		__asm POP 3
	 POP 3
; 		__asm POP 2
	 POP 2
; 		__asm POP 1
	 POP 1
; 		__asm POP 0
	 POP 0
; 		__asm POP PSW
	 POP PSW
; 		__asm POP DPL
	 POP DPL
; 		__asm POP DPH
	 POP DPH
; 		__asm POP B
	 POP B
; 		__asm POP ACC
	 POP ACC
; 		EA = 1;
			; SOURCE LINE # 107
	SETB 	EA
; 	}
			; SOURCE LINE # 108
; }
			; SOURCE LINE # 109
?C0010:
	RET  	
; END OF _os_delay

; 
; /* 系统心跳更新 */
; void os_time_tick(void)

	RSEG  ?PR?os_time_tick?TASK_SWITCH
os_time_tick:
	USING	0
			; SOURCE LINE # 112
; {
			; SOURCE LINE # 113
; 	unsigned char i;
; 	
; 	for(i=0; i<MAX_TASK; i++)
			; SOURCE LINE # 116
;---- Variable 'i?445' assigned to Register 'R7' ----
	CLR  	A
	MOV  	R7,A
?C0011:
; 	{
			; SOURCE LINE # 117
; 		if(os_tcb[i].os_tsak_wait_tick)
			; SOURCE LINE # 118
	MOV  	A,R7
	ADD  	A,ACC
	ADD  	A,ACC
	ADD  	A,#LOW (os_tcb)
	MOV  	R0,A
	MOV  	A,@R0
	JZ   	?C0013
; 		{
			; SOURCE LINE # 119
; 			os_tcb[i].os_tsak_wait_tick--;
			; SOURCE LINE # 120
	MOV  	A,R7
	ADD  	A,ACC
	ADD  	A,ACC
	ADD  	A,#LOW (os_tcb)
	MOV  	R0,A
	DEC  	@R0
; 			/*没有等待时间,则任务进入就绪状态*/
; 			if(0 == os_tcb[i].os_tsak_wait_tick)
			; SOURCE LINE # 122
	MOV  	A,R7
	ADD  	A,ACC
	ADD  	A,ACC
	ADD  	A,#LOW (os_tcb)
	MOV  	R0,A
	MOV  	A,@R0
	JNZ  	?C0013
; 			{
			; SOURCE LINE # 123
; 				os_tcb[i].suspend = 0;
			; SOURCE LINE # 124
	MOV  	A,R7
	ADD  	A,ACC
	ADD  	A,ACC
	ADD  	A,#LOW (os_tcb+03H)
	MOV  	R0,A
	CLR  	A
	MOV  	@R0,A
; 			}
			; SOURCE LINE # 125
; 		}
			; SOURCE LINE # 126
; 	}
			; SOURCE LINE # 127
?C0013:
	INC  	R7
	CJNE 	R7,#03H,?C0011
; }
			; SOURCE LINE # 128
?C0016:
	RET  	
; END OF os_time_tick

CSEG	AT	0000BH
	LJMP	timer0_isr

; 
; /* 
; 任务切换心跳 5ms
; interrupt 1是定时器中断 
; using 0 默认用,所有的寄存器会自动入栈
; 用using 1 2 3 则需要手动对r0-r7入栈,出栈(请查看寄存器组选择(看任意一本讲51的书))
; */
; void timer0_isr(void) interrupt 1

	RSEG  ?PR?timer0_isr?TASK_SWITCH
	USING	0
timer0_isr:
	PUSH 	ACC
	PUSH 	B
	PUSH 	DPH
	PUSH 	DPL
	PUSH 	PSW
	MOV  	PSW,#00H
	PUSH 	AR0
	PUSH 	AR1
	PUSH 	AR2
	PUSH 	AR3
	PUSH 	AR4
	PUSH 	AR5
	PUSH 	AR6
	PUSH 	AR7
	USING	0
			; SOURCE LINE # 136
; {
; 	unsigned char i;
; 	char cpu_sr;
; 
; 	if(os_true == os_running)
			; SOURCE LINE # 141
	JNB  	os_running,?C0025
; 	{
			; SOURCE LINE # 142
; 		os_enter_critical();
			; SOURCE LINE # 143
	LCALL	os_cpu_sr_save
	MOV  	cpu_sr?547,R7
; 		os_int_enter();
			; SOURCE LINE # 144
	LCALL	os_int_enter
; 		
; 		os_time_tick();
			; SOURCE LINE # 146
	LCALL	os_time_tick
; 		/*当然,51单片机最多只能有一次中断嵌套,os_int_count最大为2(+本次)*/
; 		if(1 == os_int_count)
			; SOURCE LINE # 148
	MOV  	A,os_int_count
	XRL  	A,#01H
	JNZ  	?C0018
; 		{
			; SOURCE LINE # 149
; 			os_tcb[os_task_running_id].os_task_stcak_top = SP;	
			; SOURCE LINE # 150
	MOV  	R7,os_task_running_id
	MOV  	A,R7
	ADD  	A,ACC
	ADD  	A,ACC
	ADD  	A,#LOW (os_tcb+01H)
	MOV  	R0,A
	MOV  	@R0,SP
; 			/*找到已经就绪,未被挂起,且优先级最高的任务(任务调度器)*/
; 			for(i=0; i<MAX_TASK; i++)
			; SOURCE LINE # 152
;---- Variable 'i?546' assigned to Register 'R7' ----
	CLR  	A
	MOV  	R7,A
?C0019:
; 			{
			; SOURCE LINE # 153
; 				if(os_task_rdy_tab & os_map_tab[i])
			; SOURCE LINE # 154
	MOV  	A,#LOW (os_map_tab)
	ADD  	A,R7
	MOV  	R0,A
	MOV  	A,@R0
	ANL  	A,os_task_rdy_tab
	JZ   	?C0021
; 				{
			; SOURCE LINE # 155
; 					/*用suspend 判断休眠时间已经到，可以执行任务部分*/
; 					if(0 == os_tcb[i].suspend)
			; SOURCE LINE # 157
	MOV  	A,R7
	ADD  	A,ACC
	ADD  	A,ACC
	ADD  	A,#LOW (os_tcb+03H)
	MOV  	R0,A
	MOV  	A,@R0
	JZ   	?C0020
; 					{
			; SOURCE LINE # 158
; 						break;
			; SOURCE LINE # 159
; 					}
			; SOURCE LINE # 160
?C0023:
; 				}
			; SOURCE LINE # 161
; 			}
			; SOURCE LINE # 162
?C0021:
	INC  	R7
	CJNE 	R7,#03H,?C0019
?C0020:
; 			/*现在执行的任务就是优先级最高的,所以不需要任务切换*/
; 			if(os_task_running_id != i)
			; SOURCE LINE # 164
	MOV  	A,os_task_running_id
	XRL  	A,R7
	JZ   	?C0018
; 			{
			; SOURCE LINE # 165
; 				/*可执行的最高优先级任务*/
; 				os_task_running_id = i;
			; SOURCE LINE # 167
	MOV  	os_task_running_id,R7
; 				/*最高优先级任务的栈顶*/
; 				/*SP是堆栈指针，指向栈顶*/
; 				SP = os_tcb[os_task_running_id].os_task_stcak_top;
			; SOURCE LINE # 170
	MOV  	R7,os_task_running_id
	MOV  	A,R7
	ADD  	A,ACC
	ADD  	A,ACC
	ADD  	A,#LOW (os_tcb+01H)
	MOV  	R0,A
	MOV  	A,@R0
	MOV  	SP,A
; 			}
			; SOURCE LINE # 171
; 		}
			; SOURCE LINE # 172
?C0018:
; 		/*清除中断标志*/
; 		TF0 = 0;
			; SOURCE LINE # 174
	CLR  	TF0
; 		/*时间重装载*/
; 		TH0 = 0xee;
			; SOURCE LINE # 176
	MOV  	TH0,#0EEH
; 		TL0 = 0x00;
			; SOURCE LINE # 177
	MOV  	TL0,#00H
; 		os_int_exit();
			; SOURCE LINE # 178
	LCALL	os_int_exit
; 		os_exit_critical();
			; SOURCE LINE # 179
	MOV  	R7,cpu_sr?547
	LCALL	_os_cpu_sr_restore
; 	}
			; SOURCE LINE # 180
; 	
; }
			; SOURCE LINE # 182
?C0025:
	POP  	AR7
	POP  	AR6
	POP  	AR5
	POP  	AR4
	POP  	AR3
	POP  	AR2
	POP  	AR1
	POP  	AR0
	POP  	PSW
	POP  	DPL
	POP  	DPH
	POP  	B
	POP  	ACC
	RETI 	
; END OF timer0_isr

	END
